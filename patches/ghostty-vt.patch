diff --git a/.gitignore b/.gitignore
index e521f8851..5caea8e86 100644
--- a/.gitignore
+++ b/.gitignore
@@ -24,3 +24,4 @@ glad.zip
 /ghostty.qcow2
 
 vgcore.*
+node_modules/
diff --git a/build.zig b/build.zig
index fa68b91b4..64f5eb712 100644
--- a/build.zig
+++ b/build.zig
@@ -260,6 +260,7 @@ pub fn build(b: *std.Build) !void {
             .root_module = mod.vt,
             .filters = test_filters,
         });
+        buildpkg.SharedDeps.addVtDeps(b, mod_vt_test);
         const mod_vt_test_run = b.addRunArtifact(mod_vt_test);
         test_lib_vt_step.dependOn(&mod_vt_test_run.step);
 
@@ -267,6 +268,7 @@ pub fn build(b: *std.Build) !void {
             .root_module = mod.vt_c,
             .filters = test_filters,
         });
+        buildpkg.SharedDeps.addVtDeps(b, mod_vt_c_test);
         const mod_vt_c_test_run = b.addRunArtifact(mod_vt_c_test);
         test_lib_vt_step.dependOn(&mod_vt_c_test_run.step);
     }
diff --git a/include/ghostty/vt.h b/include/ghostty/vt.h
index 4f8fef88e..ca9fb1d4d 100644
--- a/include/ghostty/vt.h
+++ b/include/ghostty/vt.h
@@ -28,6 +28,7 @@
  * @section groups_sec API Reference
  *
  * The API is organized into the following groups:
+ * - @ref terminal "Terminal Emulator" - Complete terminal emulator with VT parsing
  * - @ref key "Key Encoding" - Encode key events into terminal sequences
  * - @ref osc "OSC Parser" - Parse OSC (Operating System Command) sequences
  * - @ref sgr "SGR Parser" - Parse SGR (Select Graphic Rendition) sequences
@@ -74,6 +75,7 @@ extern "C" {
 
 #include <ghostty/vt/result.h>
 #include <ghostty/vt/allocator.h>
+#include <ghostty/vt/terminal.h>
 #include <ghostty/vt/osc.h>
 #include <ghostty/vt/sgr.h>
 #include <ghostty/vt/key.h>
diff --git a/src/build/Config.zig b/src/build/Config.zig
index 3a8a4e0c7..edc4cfa53 100644
--- a/src/build/Config.zig
+++ b/src/build/Config.zig
@@ -516,6 +516,7 @@ pub fn terminalOptions(self: *const Config) TerminalBuildOptions {
         .simd = self.simd,
         .oniguruma = true,
         .c_abi = false,
+        .kitty_graphics_passthrough = false,
         .slow_runtime_safety = switch (self.optimize) {
             .Debug => true,
             .ReleaseSafe,
diff --git a/src/build/GhosttyLibVt.zig b/src/build/GhosttyLibVt.zig
index aae8ace19..1ebea6af3 100644
--- a/src/build/GhosttyLibVt.zig
+++ b/src/build/GhosttyLibVt.zig
@@ -3,8 +3,15 @@ const GhosttyLibVt = @This();
 const std = @import("std");
 const assert = std.debug.assert;
 const RunStep = std.Build.Step.Run;
+const SharedDeps = @import("SharedDeps.zig");
 const GhosttyZig = @import("GhosttyZig.zig");
 
+// For dynamic linking, prefer dynamic and search by mode first.
+const dynamic_link_opts: std.Build.Module.LinkSystemLibraryOptions = .{
+    .preferred_link_mode = .dynamic,
+    .search_strategy = .mode_first,
+};
+
 /// The step that generates the file.
 step: *std.Build.Step,
 
@@ -34,6 +41,7 @@ pub fn initWasm(
 
     // There is no entrypoint for this wasm module.
     exe.entry = .disabled;
+    SharedDeps.addVtDeps(b, exe);
 
     return .{
         .step = &exe.step,
@@ -55,6 +63,7 @@ pub fn initShared(
         .root_module = zig.vt_c,
         .version = std.SemanticVersion{ .major = 0, .minor = 1, .patch = 0 },
     });
+    SharedDeps.addVtDeps(b, lib);
     lib.installHeadersDirectory(
         b.path("include/ghostty"),
         "ghostty",
diff --git a/src/build/GhosttyZig.zig b/src/build/GhosttyZig.zig
index a8d2726bc..82b9d0884 100644
--- a/src/build/GhosttyZig.zig
+++ b/src/build/GhosttyZig.zig
@@ -19,10 +19,9 @@ pub fn init(
     // Terminal module build options
     var vt_options = cfg.terminalOptions();
     vt_options.artifact = .lib;
-    // We presently don't allow Oniguruma in our Zig module at all.
-    // We should expose this as a build option in the future so we can
-    // conditionally do this.
-    vt_options.oniguruma = false;
+    vt_options.kitty_graphics_passthrough = true;
+    // Allow Oniguruma in libghostty-vt so kitty graphics and regex-backed
+    // features stay available to downstream consumers.
 
     return .{
         .vt = try initVt(
diff --git a/src/build/SharedDeps.zig b/src/build/SharedDeps.zig
index 5e2cd40b9..534a19d3c 100644
--- a/src/build/SharedDeps.zig
+++ b/src/build/SharedDeps.zig
@@ -77,6 +77,31 @@ pub fn changeEntrypoint(
     return result;
 }
 
+/// Add the minimal dependencies required for libghostty-vt modules.
+pub fn addVtDeps(b: *std.Build, step: *std.Build.Step.Compile) void {
+    const target = step.root_module.resolved_target orelse return;
+    const optimize = step.root_module.optimize orelse return;
+
+    if (b.lazyDependency("wuffs", .{
+        .target = target,
+        .optimize = optimize,
+    })) |dep| {
+        step.root_module.addImport("wuffs", dep.module("wuffs"));
+    }
+
+    if (b.lazyDependency("oniguruma", .{
+        .target = target,
+        .optimize = optimize,
+    })) |dep| {
+        step.root_module.addImport("oniguruma", dep.module("oniguruma"));
+        if (b.systemIntegrationOption("oniguruma", .{})) {
+            step.linkSystemLibrary2("oniguruma", dynamic_link_opts);
+        } else {
+            step.linkLibrary(dep.artifact("oniguruma"));
+        }
+    }
+}
+
 fn initTarget(
     self: *SharedDeps,
     b: *std.Build,
diff --git a/src/lib_vt.zig b/src/lib_vt.zig
index 03a883e20..23def191a 100644
--- a/src/lib_vt.zig
+++ b/src/lib_vt.zig
@@ -140,6 +140,51 @@ comptime {
         @export(&c.sgr_unknown_partial, .{ .name = "ghostty_sgr_unknown_partial" });
         @export(&c.sgr_attribute_tag, .{ .name = "ghostty_sgr_attribute_tag" });
         @export(&c.sgr_attribute_value, .{ .name = "ghostty_sgr_attribute_value" });
+        // Terminal lifecycle
+        @export(&c.terminal_new, .{ .name = "ghostty_terminal_new" });
+        @export(&c.terminal_new_with_config, .{ .name = "ghostty_terminal_new_with_config" });
+        @export(&c.terminal_free, .{ .name = "ghostty_terminal_free" });
+        @export(&c.terminal_resize, .{ .name = "ghostty_terminal_resize" });
+        @export(&c.terminal_set_pixel_size, .{ .name = "ghostty_terminal_set_pixel_size" });
+        @export(&c.terminal_write, .{ .name = "ghostty_terminal_write" });
+
+        // RenderState API - high-performance rendering
+        @export(&c.render_state_update, .{ .name = "ghostty_render_state_update" });
+        @export(&c.render_state_get_cols, .{ .name = "ghostty_render_state_get_cols" });
+        @export(&c.render_state_get_rows, .{ .name = "ghostty_render_state_get_rows" });
+        @export(&c.render_state_get_cursor_x, .{ .name = "ghostty_render_state_get_cursor_x" });
+        @export(&c.render_state_get_cursor_y, .{ .name = "ghostty_render_state_get_cursor_y" });
+        @export(&c.render_state_get_cursor_visible, .{ .name = "ghostty_render_state_get_cursor_visible" });
+        @export(&c.render_state_get_bg_color, .{ .name = "ghostty_render_state_get_bg_color" });
+        @export(&c.render_state_get_fg_color, .{ .name = "ghostty_render_state_get_fg_color" });
+        @export(&c.render_state_is_row_dirty, .{ .name = "ghostty_render_state_is_row_dirty" });
+        @export(&c.render_state_mark_clean, .{ .name = "ghostty_render_state_mark_clean" });
+        @export(&c.render_state_get_viewport, .{ .name = "ghostty_render_state_get_viewport" });
+        @export(&c.render_state_get_grapheme, .{ .name = "ghostty_render_state_get_grapheme" });
+
+        // Terminal modes
+        @export(&c.terminal_is_alternate_screen, .{ .name = "ghostty_terminal_is_alternate_screen" });
+        @export(&c.terminal_has_mouse_tracking, .{ .name = "ghostty_terminal_has_mouse_tracking" });
+        @export(&c.terminal_get_mode, .{ .name = "ghostty_terminal_get_mode" });
+        @export(&c.terminal_get_kitty_keyboard_flags, .{ .name = "ghostty_terminal_get_kitty_keyboard_flags" });
+        @export(&c.terminal_get_kitty_images_dirty, .{ .name = "ghostty_terminal_get_kitty_images_dirty" });
+        @export(&c.terminal_clear_kitty_images_dirty, .{ .name = "ghostty_terminal_clear_kitty_images_dirty" });
+        @export(&c.terminal_get_kitty_image_count, .{ .name = "ghostty_terminal_get_kitty_image_count" });
+        @export(&c.terminal_get_kitty_image_ids, .{ .name = "ghostty_terminal_get_kitty_image_ids" });
+        @export(&c.terminal_get_kitty_image_info, .{ .name = "ghostty_terminal_get_kitty_image_info" });
+        @export(&c.terminal_copy_kitty_image_data, .{ .name = "ghostty_terminal_copy_kitty_image_data" });
+        @export(&c.terminal_get_kitty_placement_count, .{ .name = "ghostty_terminal_get_kitty_placement_count" });
+        @export(&c.terminal_get_kitty_placements, .{ .name = "ghostty_terminal_get_kitty_placements" });
+
+        // Scrollback API
+        @export(&c.terminal_get_scrollback_length, .{ .name = "ghostty_terminal_get_scrollback_length" });
+        @export(&c.terminal_get_scrollback_line, .{ .name = "ghostty_terminal_get_scrollback_line" });
+        @export(&c.terminal_get_scrollback_grapheme, .{ .name = "ghostty_terminal_get_scrollback_grapheme" });
+        @export(&c.terminal_is_row_wrapped, .{ .name = "ghostty_terminal_is_row_wrapped" });
+
+        // Response API (for DSR and other queries)
+        @export(&c.terminal_has_response, .{ .name = "ghostty_terminal_has_response" });
+        @export(&c.terminal_read_response, .{ .name = "ghostty_terminal_read_response" });
 
         // On Wasm we need to export our allocator convenience functions.
         if (builtin.target.cpu.arch.isWasm()) {
diff --git a/src/terminal/build_options.zig b/src/terminal/build_options.zig
index e209a56fa..71a0c722f 100644
--- a/src/terminal/build_options.zig
+++ b/src/terminal/build_options.zig
@@ -28,6 +28,9 @@ pub const Options = struct {
     /// Options.
     c_abi: bool,
 
+    /// Skip decoding kitty graphics payloads and store metadata only.
+    kitty_graphics_passthrough: bool,
+
     /// Add the required build options for the terminal module.
     pub fn add(
         self: Options,
@@ -40,6 +43,7 @@ pub const Options = struct {
         opts.addOption(bool, "oniguruma", self.oniguruma);
         opts.addOption(bool, "simd", self.simd);
         opts.addOption(bool, "slow_runtime_safety", self.slow_runtime_safety);
+        opts.addOption(bool, "kitty_graphics_passthrough", self.kitty_graphics_passthrough);
 
         // These are synthesized based on other options.
         opts.addOption(bool, "kitty_graphics", self.oniguruma);
diff --git a/src/terminal/c/main.zig b/src/terminal/c/main.zig
index bc92597f5..61077215c 100644
--- a/src/terminal/c/main.zig
+++ b/src/terminal/c/main.zig
@@ -4,6 +4,7 @@ pub const key_event = @import("key_event.zig");
 pub const key_encode = @import("key_encode.zig");
 pub const paste = @import("paste.zig");
 pub const sgr = @import("sgr.zig");
+pub const terminal = @import("terminal.zig");
 
 // The full C API, unexported.
 pub const osc_new = osc.new;
@@ -52,6 +53,52 @@ pub const key_encoder_encode = key_encode.encode;
 
 pub const paste_is_safe = paste.is_safe;
 
+// Terminal lifecycle
+pub const terminal_new = terminal.new;
+pub const terminal_new_with_config = terminal.newWithConfig;
+pub const terminal_free = terminal.free;
+pub const terminal_resize = terminal.resize;
+pub const terminal_set_pixel_size = terminal.setPixelSize;
+pub const terminal_write = terminal.write;
+
+// RenderState API - high-performance rendering
+pub const render_state_update = terminal.renderStateUpdate;
+pub const render_state_get_cols = terminal.renderStateGetCols;
+pub const render_state_get_rows = terminal.renderStateGetRows;
+pub const render_state_get_cursor_x = terminal.renderStateGetCursorX;
+pub const render_state_get_cursor_y = terminal.renderStateGetCursorY;
+pub const render_state_get_cursor_visible = terminal.renderStateGetCursorVisible;
+pub const render_state_get_bg_color = terminal.renderStateGetBgColor;
+pub const render_state_get_fg_color = terminal.renderStateGetFgColor;
+pub const render_state_is_row_dirty = terminal.renderStateIsRowDirty;
+pub const render_state_mark_clean = terminal.renderStateMarkClean;
+pub const render_state_get_viewport = terminal.renderStateGetViewport;
+pub const render_state_get_grapheme = terminal.renderStateGetGrapheme;
+
+// Terminal modes
+pub const terminal_is_alternate_screen = terminal.isAlternateScreen;
+pub const terminal_has_mouse_tracking = terminal.hasMouseTracking;
+pub const terminal_get_mode = terminal.getMode;
+pub const terminal_get_kitty_keyboard_flags = terminal.getKittyKeyboardFlags;
+pub const terminal_get_kitty_images_dirty = terminal.getKittyImagesDirty;
+pub const terminal_clear_kitty_images_dirty = terminal.clearKittyImagesDirty;
+pub const terminal_get_kitty_image_count = terminal.getKittyImageCount;
+pub const terminal_get_kitty_image_ids = terminal.getKittyImageIds;
+pub const terminal_get_kitty_image_info = terminal.getKittyImageInfo;
+pub const terminal_copy_kitty_image_data = terminal.copyKittyImageData;
+pub const terminal_get_kitty_placement_count = terminal.getKittyPlacementCount;
+pub const terminal_get_kitty_placements = terminal.getKittyPlacements;
+
+// Scrollback API
+pub const terminal_get_scrollback_length = terminal.getScrollbackLength;
+pub const terminal_get_scrollback_line = terminal.getScrollbackLine;
+pub const terminal_get_scrollback_grapheme = terminal.getScrollbackGrapheme;
+pub const terminal_is_row_wrapped = terminal.isRowWrapped;
+
+// Response API (for DSR and other queries)
+pub const terminal_has_response = terminal.hasResponse;
+pub const terminal_read_response = terminal.readResponse;
+
 test {
     _ = color;
     _ = osc;
@@ -59,6 +106,7 @@ test {
     _ = key_encode;
     _ = paste;
     _ = sgr;
+    _ = terminal;
 
     // We want to make sure we run the tests for the C allocator interface.
     _ = @import("../../lib/allocator.zig");
diff --git a/src/terminal/kitty/graphics_exec.zig b/src/terminal/kitty/graphics_exec.zig
index 5b3ab915d..e49492f45 100644
--- a/src/terminal/kitty/graphics_exec.zig
+++ b/src/terminal/kitty/graphics_exec.zig
@@ -111,6 +111,13 @@ fn query(alloc: Allocator, cmd: *const Command) Response {
         .placement_id = t.placement_id,
     };
 
+    // For queries, only direct transfers are validated with data.
+    // Other mediums (file/temp/shm) may not be materialized during probing,
+    // so treat them as supported and respond OK.
+    if (t.medium != .direct) {
+        return result;
+    }
+
     // Attempt to load the image. If we cannot, then set an appropriate error.
     var loading = LoadingImage.init(alloc, cmd) catch |err| {
         encodeError(&result, err);
diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index d2877cfc2..7cf19244d 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -9,6 +9,7 @@ const fastmem = @import("../../fastmem.zig");
 const command = @import("graphics_command.zig");
 const PageList = @import("../PageList.zig");
 const wuffs = @import("wuffs");
+const build_options = @import("terminal_options");
 
 const temp_dir = struct {
     const TempDir = @import("../../os/TempDir.zig");
@@ -334,6 +335,31 @@ pub const LoadingImage = struct {
         // Decompress the data if it is compressed.
         try self.decompress(alloc);
 
+        if (comptime build_options.kitty_graphics_passthrough) {
+            if (img.format == .png) {
+                if (img.width == 0 or img.height == 0) {
+                    const dims = parsePngDimensions(self.data.items) orelse
+                        return error.DimensionsRequired;
+                    img.width = dims.width;
+                    img.height = dims.height;
+                }
+
+                if (img.width > max_dimension or img.height > max_dimension) return error.DimensionsTooLarge;
+
+                self.image.transmit_time = std.time.Instant.now() catch |err| {
+                    log.warn("failed to get time: {}", .{err});
+                    return error.InternalError;
+                };
+
+                var result = self.image;
+                const raw = try self.data.toOwnedSlice(alloc);
+                result.data = raw;
+                self.data = .{};
+                self.image = .{};
+                return result;
+            }
+        }
+
         // Decode the png if we have to
         if (img.format == .png) try self.decodePng(alloc);
 
@@ -497,6 +523,21 @@ pub const Image = struct {
     }
 };
 
+const PngDimensions = struct {
+    width: u32,
+    height: u32,
+};
+
+fn parsePngDimensions(data: []const u8) ?PngDimensions {
+    if (data.len < 24) return null;
+    const signature = [_]u8{ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    if (!std.mem.eql(u8, data[0..8], &signature)) return null;
+    const width = std.mem.readInt(u32, data[16..20], .big);
+    const height = std.mem.readInt(u32, data[20..24], .big);
+    if (width == 0 or height == 0) return null;
+    return .{ .width = width, .height = height };
+}
+
 /// The rect taken up by some image placement, in grid cells. This will
 /// be rounded up to the nearest grid cell since we can't place images
 /// in partial grid cells.
@@ -830,6 +871,10 @@ test "image load: png, not compressed, regular file" {
     var img = try loading.complete(alloc);
     defer img.deinit(alloc);
     try testing.expect(img.compression == .none);
-    try testing.expect(img.format == .rgba);
+    if (comptime build_options.kitty_graphics_passthrough) {
+        try testing.expect(img.format == .png);
+    } else {
+        try testing.expect(img.format == .rgba);
+    }
     try tmp_dir.dir.access(path, .{});
 }
diff --git a/src/terminal/render.zig b/src/terminal/render.zig
index 9d75fe4b7..b671c52d1 100644
--- a/src/terminal/render.zig
+++ b/src/terminal/render.zig
@@ -322,13 +322,14 @@ pub const RenderState = struct {
         // Colors.
         self.colors.cursor = t.colors.cursor.get();
         self.colors.palette = t.colors.palette.current;
-        bg_fg: {
+        {
             // Background/foreground can be unset initially which would
-            // depend on "default" background/foreground. The expected use
-            // case of Terminal is that the caller set their own configured
-            // defaults on load so this doesn't happen.
-            const bg = t.colors.background.get() orelse break :bg_fg;
-            const fg = t.colors.foreground.get() orelse break :bg_fg;
+            // depend on "default" background/foreground. Use sensible defaults
+            // (black background, light gray foreground) when not explicitly set.
+            const default_bg: color.RGB = .{ .r = 0, .g = 0, .b = 0 };
+            const default_fg: color.RGB = .{ .r = 204, .g = 204, .b = 204 };
+            const bg = t.colors.background.get() orelse default_bg;
+            const fg = t.colors.foreground.get() orelse default_fg;
             if (t.modes.get(.reverse_colors)) {
                 self.colors.background = fg;
                 self.colors.foreground = bg;
